## Mac时间戳在1986 - 1991 是按照GMT+0900处理

```javascript
new Date(new Date('1986-05-04 00:00:00').getTime())
// Sun May 04 1986 01:00:00 GMT+0900 (CDT)
new Date()
// Thu Sep 10 2015 18:23:43 GMT+0800 (CST)
```



### 原因

```
1986年至1991年，中华人民共和国在全国范围实行了六年夏时制，每年从4月中旬的第一个星期日2时整（北京时间）到9月中旬第一个星期日的凌晨2时整

（北京夏令时）。除1986年因是实行夏时制的第一年，从5月4日开始到9月14日结束外，其它年份均按规定的时段施行。由于省电效果不抵需要适应时间的

弊端，1992年4月5日后不再实行；
```

来源见这里[中国时区](https://zh.wikipedia.org/wiki/%E4%B8%AD%E5%9C%8B%E6%99%82%E5%8D%80) 其实就是这个原因，Mac真心做得很好。

由于当时中国国情决定，这个时间段`开始时间：1986-05-04，结束时间：1991-09-14`的时间被`拨快1小时`。所以会存在`GMT+0900（CDT）`。

### 解决方案

1、如果需要统一使用GMT+0800处理，直接使用[moment](http://momentjs.cn/)处理即可：

```
moment(525801600000).zone('+0800').format('YYYY-MM-DD HH:mm:ss');
// 当然可以通过动态获取时区处理：
(new Date()).getTimezoneOffset() / 60
```



- 如何保证服务器和客户端时间一致?

服务器和客户端不在一个时区，这个好处理，直接通过UTC时间进行通信。

- 如何保证客户端都按照指定时区处理时间。

主要是限定用户群体，例如：只支持中国，那就是东八区。所以当前用户属于哪个时区？我都需要转换为东八区的时间。

```javascript
// 一个公式
(new Date('2015-11-01').getTime()) - (8 * 60 * 60 * 1000) - ((new Date()).getTimezoneOffset() * 60 * 1000);
// 指定时区时间戳 = 选择时间时间戳 - 指定时区偏移量 + 当前时区偏移量
```

**说明：**

- `(new Date('2015-11-01').getTime())`
  其中`2015-11-01`是你选择的时间。
- `(8 * 60 * 60 * 1000)`
  这里的`8`是你想获取的时区
- `((new Date()).getTimezoneOffset() * 60 * 1000)`
  这个是固定的公式

**好吧！如果有实行夏令时国家，上面公式不成立(此处各种眼泪^-^)，请用场景1方案**