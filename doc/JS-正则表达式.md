## 正则表达式介绍

正则表达式（英语：Regular Expression，在代码中常简写为regex、regexp或RE）使用单个字符串来描述、匹配一系列符合某个句法规则的字符串搜索模式。           

搜索模式可用于文本搜索和文本替换。



## 创建一个正则表达式    

1. 使用JavaScript内置对象RegExp创建     

   ```javascript
      // 匹配手机号
      var reg1 = new RegExp('1[3-9]\\d{9}', 'g')		=> /1[3-9]\d{9}/g
      var reg2 = new RegExp(/1[3-9]\d{9}/m)			=> /1[3-9]\d{9}/m
      var reg3 = new RegExp(reg1, 'ig')				=> /1[3-9]\d{9}/gi
   ```

   RegExp(pattern, attributes)有两个参数:

   第一个参数是pattern: 匹配规则，可以是字符串、正则表达式、RegExp对象，如果是字符串`\`需要转义`\\`

   第二个是可选参数，表示匹配模式，可选值(可组合)：

   > g：global，全文搜索，不添加的话搜索到第一个结果停止搜索
   >
   > i：ingore case，忽略大小写，默认大小写敏感
   >
   > m：multiple lines，多行搜索 
   >
   > u: Unicode; 将模式视为Unicode序列点的序列 
   >
   > y: 粘性匹配; 仅匹配目标字符串中此正则表达式的lastIndex属性指示的索引(并且不尝试从任何后续的索引匹配)。

2. 表达式字面量

   正则表达式字面量由包含在斜杠之间字符组成：

   ```javascript
   var reg4 = /1[3-9]\d{9}/		=> /1[3-9]\d{9}/
   var reg5 = /1[3-9]\d{9}/g		=> /1[3-9]\d{9}/g
   ```



## 正则表达式规则

一个正则表达式模式是由简单的字符所构成的,一个字符（转义字符算一个）对应字符串一个字符.    

如`/abc/`中，仅仅当'abc'同时出现并按照这个顺序，"Hi abc"和"My name is abc"会匹配到'abc',而"Grab crab"中将不会匹配。

当你需要搜索一个比直接匹配需要更多条件的匹配时,比如寻找一个或多个 'b'，或者寻找空格，那么这时模式将要包含特殊字符。



### 制表符

| 字符 | 含义                                                         |
| :--- | :----------------------------------------------------------- |
| \t   | 水平制表符                                                   |
| \r   | 回车符                                                       |
| \n   | 换行符                                                       |
| \f   | 换页符                                                       |
| \v   | 垂直制表符                                                   |
| \0   | 空字符(c/c++ 语言中的字符串结束符，在ASCII字符集中对应空字符NULL，数值为0) |

使用例子：

```javascript
'\tda\nda'.match(/\t/)		=> ["	", index: 0, input: "	da↵da"]
'\tda\nda'.match(/\n/)		=> ["↵", index: 3, input: "	da↵da"]
```



### []、[^]、()、|、{}      

| 字符   | 含义                                                         |
| ------ | ------------------------------------------------------------ |
| [abc]  | 一个字符集合。匹配方括号的中任意字符，包括转义字符。你可以使用破折号（-）来指定一个字符范围。对于点（.）和星号（*）这样的特殊符号在一个字符集中没有特殊的意义。他们不必进行转义，不过转义也是起作用的。 [abcd] 和[a-d]是一样的， /[a-z.]+/ 和/[\w.]+/一样。 |
| [^a-c] | 一个反向字符集。也就是说， 它匹配任何没有包含在方括号中的字符。你可以使用破折号（-）来指定一个字符范围。任何普通字符在这里都是起作用的。`[^abc]`和`[^a-c]`是一样的。 |
| (x)    | 匹配 'x' 并且记住匹配项, 括号被称为 *捕获括号*。 在正则表达式的替换环节，则要使用像 `$1`、`$2`、`$n` 这样的语法，例如，` 'bar foo'.replace( /(...) (...)/, '$2 $1' )` |
| (?:x)  | 匹配 'x' 但是不记住匹配项。叫作非捕获括号.可用来定义为与正则表达式运算符一起使用的子表达式。如 /(?:foo){1,2}/则{1,2}会匹配整个 ‘foo’ 单词。 |
| x(?=y) | 匹配'x'仅仅当'x'后面跟着'y'.叫做正向肯定查找。 /Jack(?=Sprat)/匹配'Jack'仅仅当它后面跟着'Sprat'。 |
| x(?!y) | 匹配'x'仅仅当'x'后面不跟着'y',这个叫做正向否定查找。 正则表达式/\d+(?!\.)/.exec("3.141")匹配‘141’但是不是‘3.141’ |
| {n}    | n是一个正整数，匹配了前面一个字符刚好发生了n次。             |
| {n,m}  | n 和 m 都是整数。匹配前面的字符至少n次，最多m次。如果 n 或者 m 的值是0， 这个值被忽略。 |

还有一个：x|y : 匹配‘x’或者‘y’。 

使用例子：

```javascript
'@#$a2*()'.match(/[a-z][0-9]/)			=> ["a2", index: 3, input: "@#$a2*()"]
'@#$a2*()'.match(/[^a-z][^0-9]/)		=> ["@#", index: 0, input: "@#$a2*()"]
/\d+(?!.)/.exec("3.141")				=> ["141", index: 2, input: "3.141"]
'green apple'.match(/green|red/)		=> ["green", index: 0, input: "green apple"]
'dsadfoo bar23134'.match(/(foo) (bar)/)	
    => ["foo bar", "foo", "bar", index: 4, input: "dsadfoo bar23134"]
'hello worldworld'.match(/(?:world){1,2}/)	
    => ["worldworld", index: 6, input: "hello worldworld"]
'hello worldworld'.match(/(?:world){1}/)	
    => ["world", index: 6, input: "hello worldworld"]
```





'<%123ewq#$%%>'.match(/<%(.+?)%>/)[1]





