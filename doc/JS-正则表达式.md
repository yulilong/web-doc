## 正则表达式介绍

正则表达式（英语：Regular Expression，在代码中常简写为regex、regexp或RE）使用单个字符串来描述、匹配一系列符合某个句法规则的字符串搜索模式。           

搜索模式可用于文本搜索和文本替换。



## 创建一个正则表达式    

1. 使用JavaScript内置对象RegExp创建     

   ```javascript
      // 匹配手机号
      var reg1 = new RegExp('1[3-9]\\d{9}', 'g')		=> /1[3-9]\d{9}/g
      var reg2 = new RegExp(/1[3-9]\d{9}/m)			=> /1[3-9]\d{9}/m
      var reg3 = new RegExp(reg1, 'ig')				=> /1[3-9]\d{9}/gi
   ```

   RegExp(pattern, attributes)有两个参数:

   第一个参数是pattern: 匹配规则，可以是字符串、正则表达式、RegExp对象，如果是字符串`\`需要转义`\\`

   第二个是可选参数，表示匹配模式，可选值(可组合)：

   > g：global，全文搜索，不添加的话搜索到第一个结果停止搜索
   >
   > i：ingore case，忽略大小写，默认大小写敏感
   >
   > m：multiple lines，多行搜索 
   >
   > u: Unicode; 将模式视为Unicode序列点的序列 
   >
   > y: 粘性匹配; 仅匹配目标字符串中此正则表达式的lastIndex属性指示的索引(并且不尝试从任何后续的索引匹配)。

2. 表达式字面量

   正则表达式字面量由包含在斜杠之间字符组成：

   ```javascript
   var reg4 = /1[3-9]\d{9}/		=> /1[3-9]\d{9}/
   var reg5 = /1[3-9]\d{9}/g		=> /1[3-9]\d{9}/g
   ```



## 正则表达式规则

一个正则表达式模式是由简单的字符所构成的,一个字符（转义字符算一个）对应字符串一个字符.    

如`/abc/`中，仅仅当'abc'同时出现并按照这个顺序，"Hi abc"和"My name is abc"会匹配到'abc',而"Grab crab"中将不会匹配。

当你需要搜索一个比直接匹配需要更多条件的匹配时,比如寻找一个或多个 'b'，或者寻找空格，那么这时模式将要包含特殊字符。



### 制表符

| 字符 | 含义                                                         |
| :--- | :----------------------------------------------------------- |
| \t   | 水平制表符(水平tab)                                          |
| \r   | 回车符                                                       |
| \n   | 换行符                                                       |
| \f   | 换页符(\x0c)                                                 |
| \v   | 垂直制表符(等于\x0b),垂直tab                                 |
| \0   | 空字符(c/c++ 语言中的字符串结束符，在ASCII字符集中对应空字符NULL，数值为0) |

使用例子：

```javascript
'\tda\nda'.match(/\t/)		=> ["	", index: 0, input: "	da↵da"]
'\tda\nda'.match(/\n/)		=> ["↵", index: 3, input: "	da↵da"]
```



### []、`[^]`、()、|      

| 字符     | 含义                                                         |
| -------- | ------------------------------------------------------------ |
| [abc]    | 一个字符集合。匹配方括号的中任意字符，包括转义字符。你可以使用破折号（-）来指定一个字符范围。对于点（.）和星号（*）这样的特殊符号在一个字符集中没有特殊的意义。他们不必进行转义，不过转义也是起作用的。 [abcd] 和[a-d]是一样的， /[a-z.]+/ 和/[\w.]+/一样。 |
| `[^a-c]` | 一个反向字符集。也就是说， 它匹配任何没有包含在方括号中的字符。你可以使用破折号（-）来指定一个字符范围。任何普通字符在这里都是起作用的。`[^abc]`和`[^a-c]`是一样的。 |
| (x)      | 匹配 'x' 并且记住匹配项, 括号被称为 *捕获括号*。 在正则表达式的替换环节，则要使用像 `$1`、`$2`、`$n` 这样的语法，例如，` 'bar foo'.replace( /(...) (...)/, '$2 $1' )` |
| (?:x)    | 匹配 'x' 但是不记住匹配项。叫作非捕获括号.可用来定义为与正则表达式运算符一起使用的子表达式。如 /(?:foo){1,2}/则{1,2}会匹配整个 ‘foo’ 单词。 |
| x(?=y)   | 匹配'x'仅仅当'x'后面跟着'y'.叫做正向肯定查找。 /Jack(?=Sprat)/匹配'Jack'仅仅当它后面跟着'Sprat'。 |
| x(?!y)   | 匹配'x'仅仅当'x'后面不跟着'y',这个叫做正向否定查找。 正则表达式/\d+(?!\.)/.exec("3.141")匹配‘141’但是不是‘3.141’ |

还有一个：x|y : 匹配‘x’或者‘y’。 

使用例子：

```javascript
'@#$a2*()'.match(/[a-z][0-9]/)			=> ["a2", index: 3, input: "@#$a2*()"]
'@#$a2*()'.match(/[^a-z][^0-9]/)		=> ["@#", index: 0, input: "@#$a2*()"]
/\d+(?!.)/.exec("3.141")				=> ["141", index: 2, input: "3.141"]
'green apple'.match(/green|red/)		=> ["green", index: 0, input: "green apple"]
'dsadfoo bar23134'.match(/(foo) (bar)/)	
    => ["foo bar", "foo", "bar", index: 4, input: "dsadfoo bar23134"]
```

## 预定义

预定义： 一个特殊字符代表了一类字符的合集。

| 字符 | 含义                                     | 相当于  |
| ---- | :------------------------------------------ | ------- |
| .    | (小数点)匹配除换行符之外的任何单个字符 | `[^\r\n]` |
| \d | 数字字符 | ` [0-9]` |
| \D | 非数字字符 | ` [^0-9]` |
| \s | 空白符( 空格、制表符、换页符和换行符) | ` \f\n\r\t\v\u00a0\u1680\u180e\u2000-\u200a\u2028\u2029\u202f\u205f\u3000\ufeff` |
| \S | 匹配一个非空白字符。 | `[^\s]` |
| \w | 匹配一个单字字符（字母、数字或者下划线） | ` [A-Za-z0-9_]` |
| \W | 匹配一个非单字字符 | ` [^A-Za-z0-9_]` |

## 边界

规定一个特殊字符表示匹配的边界。

| 字符 | 含义                                                         |
| ---- | ------------------------------------------------------------ |
| ^    | 匹配输入的开始, 多行标志被设置为true，那么也匹配换行符后紧跟的位置。 /^A/ 不会匹配 "an A" 中的 'A', 会匹配 "An E" 中的 'A'。注：^在[]中含义就变了，`[^]`表示取反。 |
| $    | 匹配输入的结束。如果多行标示被设置为true，那么也匹配换行符前的位置。 /t$/ 并不会匹配 "eater" 中的 't'，但是会匹配 "eat" 中的 't'。 |
| \b   | 词的边界。 /\bm/匹配“moon”中得‘m’， /oon\b/匹配"moon"中得'oon'。 |
| \B   | 匹配一个非单词边界。他匹配一个前后字符都是相同类型的位置：都是单词或者都不是单词。一个字符串的开始和结尾都被认为是非单词。 |

例子：

```javascript
var str = 'hello1 whello9orld 12-hello8-3456 hello0'
str.match(/^hello\d/g)		=> ["hello1"]
str.match(/hello\d$/g)		=> ["hello0"]
str.match(/\bhello\d\b/g)	=> ["hello1", "hello8", "hello0"] // -也用于区分单词边界
str.match(/\Bhello\d\B/g)	=> ["hello9"]
str.match(/\Bhello\d/g)		=> ["hello9"]
str.match(/hello\d\B/g)		=> ["hello9"]
```



## 量词

下面介绍的字符可以表示一个字符出现多次的定义。

| 字符 | 含义                                                         |
| ---- | ------------------------------------------------------------ |
| ?    | 匹配前面一个表达式0次或者1次。等价于 {0,1}。 （最多出现一次） |
| +    | 匹配前面一个表达式1次或者多次。等价于 {1,}。 （至少出现一次） |
| *     | 匹配前一个表达式0次或多次。等价于 {0,}。 （任意次） |
| {n} | n是一个正整数，匹配了前面一个字符刚好发生了n次。 |
| {n,m} | n和m都是整数。匹配前面的字符至少n次,最多m次。如果n或者m的值是0,这个值被忽略。 |
| {n,} | 前面一个字符至少出现n次 |

例子：

```javascript
// 匹配手机号
'dsa+8613244043289sss'.match(/(\+86)?1[2-8]\d{9}/)	
// ["+8613244043289", "+86", index: 3, input: "dsa+8613244043289sss"]
'dsa13244043289sss'.match(/(?:\+86)?1[2-8]\d{9}/)	
// ["13244043289", index: 3, input: "dsa13244043289sss"]
'hello worldworld'.match(/(?:world){1,2}/)	
    => ["worldworld", index: 6, input: "hello worldworld"]
'hello worldworld'.match(/(?:world){1}/)	
    => ["world", index: 6, input: "hello worldworld"]
```



## 贪婪模式和非贪婪模式

### 贪婪模式(默认)    

正则表达式规则中，量词的匹配是尽可能多的匹配，也就是贪婪模式。

```javascript
'a+8613244043289s'.match(/\d{4,8}/g)	=> ["86132440", "43289"]
```

### 非贪婪模式

也可以设置量词(量词后加上`?`即可)让正则表达式尽可能少的匹配，称非贪婪模式。

```javascript
'a+8613244043289s'.match(/\d{4,8}?/g)	=> ["8613", "2440", "4328"]
```



## javascript中正则表达式的相关方法

### RegExp对象的方法

* ## RegExp.prototype.test

test方法

'<%123ewq#$%%>'.match(/<%(.+?)%>/)[1]





